/*----- PROTECTED REGION ID(SpecBoardInterface.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        SpecBoardInterface.cpp
//
// description : C++ source for the SpecBoardInterface class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SpecBoardInterface are implemented in this file.
//
// project :     Simple PCI FMC Carrier (SPEC) Tango DS interface
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SpecBoardInterface.h>
#include <SpecBoardInterfaceClass.h>

extern "C"
{
#include "speclib.h"
}

/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface.cpp

/**
 *  SpecBoardInterface class description:
 *    The Simple PCIe FMC carrier (SPEC) board is a FPGA based board with SFP connector and PCIe interface (throw the Gennum GN4124 chip bridge). It is under CERN Open Hardware License (CERN OHL v1.2).
 *    The SPEC board can hold one FMC card for ADC, DAC, DIO... It can also be used as a standard node for the White Rabbit system.
 *    Check the web page http://www.ohwr.org/projects/spec/wiki for full documentation and sources.
 *    
 *    This class is a simple basic interface for the SPEC board. It allows to:
 *      * load the FPGA bitstream
 *      * read/write registers of the user and gn4124 cores.
 *    
 *    You will need the libspec library to build and run this class:
 *      * git clone git@ohwr.org:fmc-projects/spec/spec-sw.git
 *      * cd spec-sw/tools
 *      * make
 *      * libspec.a and libspec.so are available
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name       |  Method name
//================================================================
//  State              |  Inherited (no method)
//  Status             |  Inherited (no method)
//  ReadRegister       |  read_register
//  ReadRegisterBlock  |  read_register_block
//  WriteRegister      |  write_register
//  LoadBitstream      |  load_bitstream
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  barArea            |  Tango::DevShort	Scalar
//  bitfile            |  Tango::DevString	Scalar
//  readAddress        |  Tango::DevULong	Scalar
//  writeAddress       |  Tango::DevULong	Scalar
//  readValue          |  Tango::DevULong	Scalar
//  writeValue         |  Tango::DevULong	Scalar
//  sizeReadBlock      |  Tango::DevULong	Scalar
//  readRegisterBlock  |  Tango::DevULong	Spectrum  ( max = 65536)
//================================================================

namespace SpecBoardInterface_ns
{
/*----- PROTECTED REGION ID(SpecBoardInterface::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::SpecBoardInterface()
 *	Description : Constructors for a Tango device
 *                implementing the classSpecBoardInterface
 */
//--------------------------------------------------------
SpecBoardInterface::SpecBoardInterface(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SpecBoardInterface::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::constructor_1
}
//--------------------------------------------------------
SpecBoardInterface::SpecBoardInterface(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(SpecBoardInterface::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::constructor_2
}
//--------------------------------------------------------
SpecBoardInterface::SpecBoardInterface(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(SpecBoardInterface::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SpecBoardInterface::delete_device()
{
	DEBUG_STREAM << "SpecBoardInterface::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::delete_device
	delete[] attr_barArea_read;
	delete[] attr_bitfile_read;
	delete[] attr_readAddress_read;
	delete[] attr_writeAddress_read;
	delete[] attr_readValue_read;
	delete[] attr_sizeReadBlock_read;
	delete[] attr_readRegisterBlock_read;
}

//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SpecBoardInterface::init_device()
{
	DEBUG_STREAM << "SpecBoardInterface::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::init_device_before
	
	//	No device property to be read from database
	
	attr_barArea_read = new Tango::DevShort[1];
	attr_bitfile_read = new Tango::DevString[1];
	attr_readAddress_read = new Tango::DevULong[1];
	attr_writeAddress_read = new Tango::DevULong[1];
	attr_readValue_read = new Tango::DevULong[1];
	attr_sizeReadBlock_read = new Tango::DevULong[1];
	attr_readRegisterBlock_read = new Tango::DevULong[65536];
	/*----- PROTECTED REGION ID(SpecBoardInterface::init_device) ENABLED START -----*/
	
	//	Initialize device
	*attr_barArea_read=0;
	*attr_bitfile_read=const_cast<char*>("bitstream.bit");
	*attr_readAddress_read=0;
	*attr_writeAddress_read=0;
	*attr_readValue_read=0;
	*attr_sizeReadBlock_read=1;
	bitfileExist=false;
	valueToWrite=0xffffffff;
	checkBarAreaEnumLabelsProperty();
	void *card = spec_open(-1,-1);
	if(!card)
	{
		specFound=false;
		cerr << "No SPEC card found... Verify the SPEC is recognized on the "
				"PCI Express bus by typing the lspci -H1 command" << endl;
		set_state(Tango::FAULT);
		set_status("No SPEC card found... Verify the SPEC is recognized on the "
				"PCI Express bus by typing the lspci -H1 command\n"
				"You should find tthe following line:\n"
				"Non-VGA unclassified device: CERN/ECP/EDU Device 018d (rev 03)"
				"\nIf this line doesn't appear, there is a problem with the PCIe"
				" slot. Try to check the BIOS settings.\n");
	}
	else
	{
		specFound=true;
		set_state(Tango::ON);
		set_status("SPEC card found.\n");
	}
	spec_close(card);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::init_device
}


//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SpecBoardInterface::always_executed_hook()
{
	DEBUG_STREAM << "SpecBoardInterface::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SpecBoardInterface::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SpecBoardInterface::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void SpecBoardInterface::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SpecBoardInterface::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute barArea related method
 *	Description: This is the PCIe BAR area on which you want read/write registers.
 *               BAR0 :FPGA Whishbone bus registers. Access internal FPGA embedded system.
 *               BAR4 :GN4124 control registers. Access system control as boot mode or loading FPGA bitstream.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::read_barArea(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_barArea(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_barArea) ENABLED START -----*/
	//	Set the attribute value
	//we have to divide by 4 here, becasue we use EnumLabels property.
	//EnumLabels take 0 or 1. But the real value is 0 or 4.
	Tango::DevShort enumBar=attr_barArea_read[0]/4;
	attr.set_value(&enumBar);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_barArea
}
//--------------------------------------------------------
/**
 *	Write attribute barArea related method
 *	Description: This is the PCIe BAR area on which you want read/write registers.
 *               BAR0 :FPGA Whishbone bus registers. Access internal FPGA embedded system.
 *               BAR4 :GN4124 control registers. Access system control as boot mode or loading FPGA bitstream.
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::write_barArea(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::write_barArea(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_barArea) ENABLED START -----*/
	if(w_val==1)
	{
		*attr_barArea_read=4;
	}
	else
	{
		*attr_barArea_read=0;
	}	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_barArea
}
//--------------------------------------------------------
/**
 *	Read attribute bitfile related method
 *	Description: Path of the bitstream to load in the FPGA.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::read_bitfile(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_bitfile(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_bitfile) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_bitfile_read);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_bitfile
}
//--------------------------------------------------------
/**
 *	Write attribute bitfile related method
 *	Description: Path of the bitstream to load in the FPGA.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::write_bitfile(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::write_bitfile(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_bitfile) ENABLED START -----*/
    ifstream f(w_val);
    if (f.good())
    {
    	//file exists
    	*attr_bitfile_read=w_val;
    	f.close();
        set_state(Tango::ON);
        set_status("The bitfile exists\n");
        bitfileExist=true;
    }
    else
    {
    	//file doesn't exist
    	*attr_bitfile_read=const_cast<char*>("bitstream.bit");
        f.close();
        set_state(Tango::ALARM);
        set_status("The bitfile doesn't exist\nUnable to program the FPGA\n");
        bitfileExist=false;
    }	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_bitfile
}
//--------------------------------------------------------
/**
 *	Read attribute readAddress related method
 *	Description: Address of the register to read
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::read_readAddress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_readAddress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_readAddress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_readAddress_read);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_readAddress
}
//--------------------------------------------------------
/**
 *	Write attribute readAddress related method
 *	Description: Address of the register to read
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::write_readAddress(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::write_readAddress(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_readAddress) ENABLED START -----*/
	if( w_val & 0x3 )
	{
		set_state(Tango::ALARM);
		set_status("Address is not a multiple of 4. "
				"Unable to read register.\n");
		*attr_readAddress_read=0;
		attr.set_write_value(0);
	}
	else
	{
		set_state(Tango::ON);
		char buf[128];
		sprintf(buf,"Read Address set to 0x%08X\n",w_val);
		string newStatus(buf);
		set_status(newStatus);
		*attr_readAddress_read=w_val;
	}
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_readAddress
}
//--------------------------------------------------------
/**
 *	Read attribute writeAddress related method
 *	Description: Address of the register to write
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::read_writeAddress(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_writeAddress(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_writeAddress) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_writeAddress_read);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_writeAddress
}
//--------------------------------------------------------
/**
 *	Write attribute writeAddress related method
 *	Description: Address of the register to write
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::write_writeAddress(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::write_writeAddress(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_writeAddress) ENABLED START -----*/
	if( w_val & 0x3 )
	{
		set_state(Tango::ALARM);
		set_status("Address is not a multiple of 4. "
				"Unable to write register.\n");
		*attr_writeAddress_read=0;
		attr.set_write_value(0);
	}
	else
	{
		set_state(Tango::ON);
		char buf[128];
		sprintf(buf,"Write Address set to 0x%08X\n",w_val);
		string newStatus(buf);
		set_status(newStatus);
		*attr_writeAddress_read=w_val;
	}
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_writeAddress
}
//--------------------------------------------------------
/**
 *	Read attribute readValue related method
 *	Description: Value read at readAddress
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::read_readValue(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_readValue(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_readValue) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_readValue_read);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_readValue
}
//--------------------------------------------------------
/**
 *	Write attribute writeValue related method
 *	Description: Value to write at writeAddress
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::write_writeValue(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::write_writeValue(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_writeValue) ENABLED START -----*/
	valueToWrite=w_val;
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_writeValue
}
//--------------------------------------------------------
/**
 *	Read attribute sizeReadBlock related method
 *	Description: Size of the register block to read (number of registers to read).
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::read_sizeReadBlock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_sizeReadBlock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_sizeReadBlock) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_sizeReadBlock_read);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_sizeReadBlock
}
//--------------------------------------------------------
/**
 *	Write attribute sizeReadBlock related method
 *	Description: Size of the register block to read (number of registers to read).
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SpecBoardInterface::write_sizeReadBlock(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::write_sizeReadBlock(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevULong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_sizeReadBlock) ENABLED START -----*/
	*attr_sizeReadBlock_read=w_val;
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_sizeReadBlock
}
//--------------------------------------------------------
/**
 *	Read attribute readRegisterBlock related method
 *	Description: This spectrum contains the values of a block of registers.
 *               The block starts at address readAddress and reads next registers until sizeReadBlock is reached.
 *
 *	Data type:	Tango::DevULong
 *	Attr type:	Spectrum max = 65536
 */
//--------------------------------------------------------
void SpecBoardInterface::read_readRegisterBlock(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SpecBoardInterface::read_readRegisterBlock(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_readRegisterBlock) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_readRegisterBlock_read,attr_sizeReadBlock_read[0]);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_readRegisterBlock
}

//--------------------------------------------------------
/**
 *	Method      : SpecBoardInterface::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SpecBoardInterface::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SpecBoardInterface::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command ReadRegister related method
 *	Description: Read a register of the barArea (whishbone or gn4124) at the address readAddress (barArea base_address + offset).
 *               Registers are 32 bits wide.
 *
 */
//--------------------------------------------------------
void SpecBoardInterface::read_register()
{
	DEBUG_STREAM << "SpecBoardInterface::ReadRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_register) ENABLED START -----*/
	
	//	Add your own code
	void *card=spec_open(-1,-1);
	if(!card)
	{
		set_state(Tango::ALARM);
		set_status("Failed to open SPEC. Unable to read register.\n");
	}
	else
	{
		void *map_base=spec_get_base(card,attr_barArea_read[0]);
		specReadRegister(map_base,attr_readAddress_read[0],attr_readValue_read);
		set_state(Tango::ON);
		char buf[128];
		sprintf(buf,"Register read at address 0x%08X\n",
				attr_readAddress_read[0]);
		string newStatus(buf);
		set_status(newStatus);
	}
	spec_close(card);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_register
}
//--------------------------------------------------------
/**
 *	Command ReadRegisterBlock related method
 *	Description: Read a block of registers in the barArea (whishbone or gn4124).
 *               The block starts at the address readAddress (barArea base_address + offset) and reads next registers until sizeReadBlock is reached.
 *               Registers are 32 bits wide.
 *
 */
//--------------------------------------------------------
void SpecBoardInterface::read_register_block()
{
	DEBUG_STREAM << "SpecBoardInterface::ReadRegisterBlock()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::read_register_block) ENABLED START -----*/
	
	//	Add your own code
	void *card=spec_open(-1,-1);
	if(!card)
	{
		set_state(Tango::ALARM);
		set_status("Failed to open SPEC. Unable to read register.\n");
	}
	else
	{
		uint32_t i=0;
		uint32_t buffer;
		void *map_base=spec_get_base(card,attr_barArea_read[0]);
		for(i=0;i<attr_sizeReadBlock_read[0];++i)
		{
			specReadRegister(map_base,attr_readAddress_read[0]+(i*4),&buffer);
			attr_readRegisterBlock_read[i]=buffer;
		}
		set_state(Tango::ON);
		char buf[128];
		sprintf(buf,"Register block read from address 0x%08X to 0x%08X\n",
				attr_readAddress_read[0],
				attr_readAddress_read[0] + (i-1)*4);
		string newStatus(buf);
		set_status(newStatus);
	}
	spec_close(card);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::read_register_block
}
//--------------------------------------------------------
/**
 *	Command WriteRegister related method
 *	Description: Write writeValue in a register of the barArea (whisbone or gn4124) at the address writeAddress (barArea base_address + offset).
 *               Registers are 32 bits wide.
 *
 */
//--------------------------------------------------------
void SpecBoardInterface::write_register()
{
	DEBUG_STREAM << "SpecBoardInterface::WriteRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::write_register) ENABLED START -----*/
	
	//	Add your own code
	void *card=spec_open(-1,-1);
	if(!card)
	{
		set_state(Tango::ALARM);
		set_status("Failed to open SPEC. Unable to read register.\n");
	}
	else
	{
		void *map_base=spec_get_base(card,attr_barArea_read[0]);
		specWriteRegister(map_base,attr_writeAddress_read[0],valueToWrite);
		set_state(Tango::ON);
		char buf[128];
		sprintf(buf,"Value 0x%08X written at address 0x%08X\n",
				valueToWrite,
				attr_writeAddress_read[0]);
		string newStatus(buf);
		set_status(newStatus);
	}
	spec_close(card);
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::write_register
}
//--------------------------------------------------------
/**
 *	Command LoadBitstream related method
 *	Description: Load the bitstream bitfile in the FPGA.
 *               The bitfile must be the full path (/full/path/bitstream.bit) of the bitstream.
 *               The barArea attribute is ignored because this command obviously uses the BAR4 area dedicated to the GN4124 for programming the FPGA.
 *
 */
//--------------------------------------------------------
void SpecBoardInterface::load_bitstream()
{
	DEBUG_STREAM << "SpecBoardInterface::LoadBitstream()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SpecBoardInterface::load_bitstream) ENABLED START -----*/
	
	//	Add your own code
	void *card=spec_open(-1,-1);
	if(!card)
	{
		set_state(Tango::ALARM);
		set_status("Failed to open SPEC. Unable to read register.\n");
	}
	else
	{
		if( spec_load_bitstream(card,attr_bitfile_read[0])<0 )
		{
			set_state(Tango::ALARM);
			set_status("Failed to load FPGA\n");
		}
		else
		{
			set_state(Tango::ON);
			set_status("FPGA bitstream loaded\n");
		}
	}
	spec_close(card);	
	/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::load_bitstream
}

/*----- PROTECTED REGION ID(SpecBoardInterface::namespace_ending) ENABLED START -----*/

//	Additional Methods
void SpecBoardInterface::checkBarAreaEnumLabelsProperty(void)
{
    Tango::DbData data;
    bool needWriteEnumLabels = false;
    bool findEnumLables = false;
    const char *attribute="barArea";
    vector<string> enumLabels;
    enumLabels.push_back("Whisbone");
    enumLabels.push_back("GN4124");

    data.push_back(Tango::DbDatum(attribute));

    db_dev->get_attribute_property(data);

    // check if attribute property is correct
    for (unsigned int i = 0; i < data.size(); i++) {
        if (data[i].name == "enumLabels") {
            findEnumLables = true;
            cout << data[i].name << endl;
            if (data[i].size() == enumLabels.size()) {
                for (unsigned int j = 0; j < data[i].value_string.size(); j++) {
                    if (data[i].value_string[j] != enumLabels[j]) {
                        needWriteEnumLabels = true;
                    }
                    cout << data[i].value_string[j] << " " << enumLabels[j] << endl;
                    cout << (data[i].value_string[j] != enumLabels[j]) << endl;
                }
            } else {
                needWriteEnumLabels = true;
            }
        }
    }

    // set correct attribute property
    if (!findEnumLables || needWriteEnumLabels) {

        Tango::DbDatum datumMode(attribute), datumEnum("enumLabels");
        Tango::DbData dataNew;

        datumMode << (short) 1;

        /*vector<string> enumlab;
        enumlab.clear();
        enumlab = enumLabels ;*/
        datumEnum << enumLabels;
        dataNew.push_back(datumMode);
        dataNew.push_back(datumEnum);

        db_dev->put_attribute_property(dataNew);
        cout << "enumLabels" << attribute << " was write" << endl;
    } else {
        cout << "don't need to write enumLabels" << attribute << endl;
    }
}

void SpecBoardInterface::specReadRegister(void *map_base, uint32_t address,
		uint32_t *val)
{
	*val=*(volatile uint32_t*)((uintptr_t)map_base + address);
}

void SpecBoardInterface::specWriteRegister(void *map_base, uint32_t address,
		uint32_t val)
{
	*(volatile uint32_t*)((uintptr_t)map_base + address)=val;
}

/*----- PROTECTED REGION END -----*/	//	SpecBoardInterface::namespace_ending
} //	namespace
